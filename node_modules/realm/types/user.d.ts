////////////////////////////////////////////////////////////////////////////
//
// Copyright 2020 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////

// As we're writing this declarations file manually, it's okay to use triple slash references
/* eslint-disable @typescript-eslint/triple-slash-reference */

declare namespace Realm {
    /**
     * Representation of an authenticated user of an app.
     */
    class User<
        FunctionsFactoryType extends object = DefaultFunctionsFactory,
        CustomDataType extends object = any
    > {
        /**
         * The automatically-generated internal ID of the user.
         */
        readonly id: string;

        /**
         * The provider type for the user.
         */
        readonly providerType: string;

        /**
         * The id of the device.
         */
        readonly deviceId: string | null;

        /**
         * The state of the user.
         */
        readonly state: UserState;

        /**
         * The identities of the user at any of the app's authentication providers.
         */
        readonly identities: UserIdentity[];

        /**
         * The access token used when requesting a new access token.
         */
        readonly accessToken: string | null;

        /**
         * The refresh token used when requesting a new access token.
         */
        readonly refreshToken: string | null;

        /**
         * You can store arbitrary data about your application users in a MongoDB collection and configure MongoDB Realm to automatically expose each user’s data in a field of their user object.
         * For example, you might store a user’s preferred language, date of birth, or their local timezone.
         *
         * If this value has not been configured, it will be empty.
         */
        readonly customData: CustomDataType;

        /**
         * A profile containing additional information about the user.
         */
        readonly profile: UserProfile;

        /**
         * Use this to call functions defined by the MongoDB Realm app, as this user.
         */
        readonly functions: FunctionsFactoryType & BaseFunctionsFactory;

        /**
         * Perform operations related to the API-key auth provider.
         */
        readonly apiKeys: Realm.Auth.ApiKeyAuth;

        /**
         * Log out the user.
         *
         * @returns A promise that resolves once the user has been logged out of the app.
         */
        logOut(): Promise<void>;

        /**
         * Link the user with an identity represented by another set of credentials.
         *
         * @param credentials The credentials to use when linking.
         */
        linkCredentials(credentials: Credentials): Promise<void>;

        /**
         * Call a remote MongoDB Realm function by its name.
         * Note: Consider using `functions[name]()` instead of calling this method.
         *
         * @example
         * // These are all equivalent:
         * await user.callFunction("doThing", [a1, a2, a3]);
         * await user.functions.doThing(a1, a2, a3);
         * await user.functions["doThing"](a1, a2, a3);
         *
         * @example
         * // The methods returned from the functions object are bound, which is why it's okay to store the function in a variable before calling it:
         * const doThing = user.functions.doThing;
         * await doThing(a1);
         * await doThing(a2);
         *
         * @param name Name of the function.
         * @param args Arguments passed to the function.
         */
        callFunction(name: string, ...args: any[]): Promise<any>;

        /**
         * Refresh the access token and derive custom data from it.
         *
         * @returns The newly fetched custom data.
         */
        refreshCustomData(): Promise<CustomDataType>;

        /**
         * Use the Push service to enable sending push messages to this user via Firebase Cloud Messaging (FCM).
         *
         * @returns An service client with methods to register and deregister the device on the user.
         */
        push(serviceName: string): Realm.Services.Push;
    }

    /**
     * The state of a user.
     */
    enum UserState {
        /** Authenticated and available to communicate with services. */
        Active = "active",
        /** Logged out, but ready to be logged in. */
        LoggedOut = "logged-out",
        /** Removed from the app entirely. */
        Removed = "removed",
    }

    /**
     * The type of a user.
     */
    enum UserType {
        /** A normal end-user created this user */
        Normal = "normal",
        /** The user was created by the server */
        Server = "server",
    }

    // TODO: Implement storing these identities on the user

    /**
     * A user's identity with a particular authentication provider.
     */
    interface UserIdentity {
        /**
         * The id of the user.
         */
        userId: string;

        /**
         * The type of the provider associated with the identity.
         */
        providerType: string;
    }

    /**
     * An extended profile with detailed information about the user.
     */
    interface UserProfile {
        /**
         * The commonly displayed name of the user.
         */
        name?: string;

        /**
         * The users email address.
         */
        email?: string;

        /**
         * A URL referencing a picture associated with the user.
         */
        pictureUrl?: string;

        /**
         * The users first name.
         */
        firstName?: string;

        /**
         * The users last name.
         */
        lastName?: string;

        /**
         * The users gender.
         */
        gender?: string; // TODO: Determine if this is free-text or actually an enum type.

        /**
         * The users birthday.
         */
        birthday?: string; // TODO: Determine the format.

        /**
         * The minimal age of the user.
         */
        minAge?: string;

        /**
         * The maximal age of the user.
         */
        maxAge?: string;

        /**
         * The type of user
         * // TODO: Determine the meaning of the different possibilities.
         */
        type: UserType;
    }
}